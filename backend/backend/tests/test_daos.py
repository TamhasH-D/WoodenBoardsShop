import pytest
import uuid # Added import
from sqlalchemy.ext.asyncio import AsyncSession

from backend.daos.product_daos import ProductDAO
from backend.daos.wood_type_daos import WoodTypeDAO
from backend.daos.seller_daos import SellerDAO # Added import
from backend.dtos.product_dtos import ProductInputDTO
from backend.dtos.wood_type_dtos import WoodTypeInputDTO
from backend.dtos.seller_dtos import SellerInputDTO # Added import
from backend.exceptions import DuplicateEntryError
from tests.factories import SellerFactory, WoodTypeFactory # SellerFactory was already here


@pytest.mark.asyncio
async def test_wood_type_dao_create_duplicate_name(db_session: AsyncSession):
    """Test creating a wood type with a duplicate name raises DuplicateEntryError."""
    wood_type_dao = WoodTypeDAO(db_session)
    dto = WoodTypeInputDTO(name="Test Unique Wood", description="A test description")

    # First creation should succeed
    await wood_type_dao.create(dto)

    # Second creation with the same name (case-insensitive check in DAO)
    dto_duplicate_same_case = WoodTypeInputDTO(name="Test Unique Wood", description="Another description")
    with pytest.raises(DuplicateEntryError) as excinfo_same_case:
        await wood_type_dao.create(dto_duplicate_same_case)
    assert "A wood type with this name already exists." in str(excinfo_same_case.value)

    # Third creation with different case
    dto_duplicate_different_case = WoodTypeInputDTO(name="test unique wood", description="Yet another description")
    with pytest.raises(DuplicateEntryError) as excinfo_different_case:
        await wood_type_dao.create(dto_duplicate_different_case)
    assert "A wood type with this name already exists." in str(excinfo_different_case.value)


@pytest.mark.asyncio
async def test_product_dao_create_duplicate_title_for_seller(db_session: AsyncSession):
    """Test creating a product with a duplicate title for the same seller raises DuplicateEntryError."""
    # Note: Explicitly setting SellerFactory._meta.sqlalchemy_session is not needed
    # due to the autouse inject_session fixture in conftest.py.
    # SellerFactory._meta.sqlalchemy_session = db_session
    # WoodTypeFactory._meta.sqlalchemy_session = db_session

    product_dao = ProductDAO(db_session)

    # Create a seller
    seller = await SellerFactory.create()

    # Create a wood_type (needed for product creation, though ProductDAO doesn't check its duplication)
    wood_type = await WoodTypeFactory.create(name="Test Wood for Product Test")

    dto = ProductInputDTO(
        title="Unique Product Title",
        descrioption="Test product description", # Matches model field name
        price=100.0,
        volume=10.0,
        seller_id=seller.id,
        wood_type_id=wood_type.id,
        delivery_possible=True,
    )

    # First creation should succeed
    await product_dao.create(dto)

    # Second creation with the same title and seller_id
    dto_duplicate_same_case = ProductInputDTO(
        title="Unique Product Title", # Same title
        descrioption="Another test product description",
        price=150.0,
        volume=5.0,
        seller_id=seller.id, # Same seller
        wood_type_id=wood_type.id,
        delivery_possible=False,
    )
    with pytest.raises(DuplicateEntryError) as excinfo_same_case:
        await product_dao.create(dto_duplicate_same_case)
    assert "A product with this title already exists for this seller." in str(excinfo_same_case.value)

    # Third creation with different case title but same seller_id
    dto_duplicate_different_case = ProductInputDTO(
        title="unique product title", # Different case title
        descrioption="Yet another test product description",
        price=200.0,
        volume=12.0,
        seller_id=seller.id, # Same seller
        wood_type_id=wood_type.id,
        delivery_possible=True,
    )
    with pytest.raises(DuplicateEntryError) as excinfo_different_case:
        await product_dao.create(dto_duplicate_different_case)
    assert "A product with this title already exists for this seller." in str(excinfo_different_case.value)


@pytest.mark.asyncio
async def test_base_dao_handles_integrity_error_on_create(db_session: AsyncSession):
    """
    Test that BaseDAO.create (via SellerDAO) catches IntegrityError
    for DB-level unique constraints and raises DuplicateEntryError.
    """
    seller_dao = SellerDAO(db_session)

    # Generate a fixed keycloak_uuid for testing uniqueness
    # The seller model has a unique constraint on keycloak_uuid
    test_keycloak_uuid = uuid.uuid4()

    dto1 = SellerInputDTO(
        keycloak_uuid=test_keycloak_uuid,
        # id will be auto-generated by DB if not provided in DTO
        # is_online defaults to False in model
    )

    # First creation should succeed
    # The BaseDAO.create method itself does not have unique_check_params by default for keycloak_uuid
    # So, this relies on the DB unique constraint to trigger IntegrityError
    created_seller1 = await seller_dao.create(dto1)
    # Normally, BaseFactory.create calls session.commit(), but here we use DAO directly.
    # The db_session fixture handles rollback, so explicit commit isn't strictly needed for isolation,
    # but flush helps ensure the first object is in the session's identity map and DB state
    # before the second attempt if the DB constraint relies on committed state.
    await db_session.flush()

    # Attempt to create another seller with the same keycloak_uuid
    dto2 = SellerInputDTO(
        keycloak_uuid=test_keycloak_uuid,
    )

    with pytest.raises(DuplicateEntryError) as excinfo:
        # This call should trigger an IntegrityError from the database due to the unique
        # constraint on keycloak_uuid, which BaseDAO.create should catch and convert
        # to DuplicateEntryError.
        await seller_dao.create(dto2)

    # Check the generic message from BaseDAO's IntegrityError handler
    assert "Database integrity violation: A record with conflicting unique values already exists." in str(excinfo.value)

    # Optionally, verify that only one seller with this keycloak_uuid exists
    # This requires the Seller model to be imported, or using a generic query if possible
    # from backend.models.seller_models import Seller
    # result = await db_session.execute(
    #     sa.select(Seller).where(Seller.keycloak_uuid == test_keycloak_uuid)
    # )
    # sellers_with_uuid = result.scalars().all()
    # assert len(sellers_with_uuid) == 1
    # For now, the exception check is the primary goal.
    # The test's db_session fixture will roll back, so the DB will be clean for next tests.
    # If we wanted to check count, we'd need to ensure the first one is truly committed
    # and the second one fails before commit but after add/flush.
    # However, the current setup with flush and DAO's try/except for IntegrityError
    # during its own flush is what we are testing.
