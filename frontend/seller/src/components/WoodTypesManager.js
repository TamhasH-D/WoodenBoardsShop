import React, { useState, useCallback } from 'react';
import { useApi, useApiMutation } from '../hooks/useApi';
import { apiService } from '../services/api';
import { SELLER_TEXTS } from '../utils/localization';

// Helper function for Russian pluralization
const getPriceRecordsText = (count) => {
  if (count === 1) return SELLER_TEXTS.PRICE_RECORD_SINGLE;
  if (count >= 2 && count <= 4) return SELLER_TEXTS.PRICE_RECORDS_FEW;
  return SELLER_TEXTS.PRICE_RECORDS;
};

function WoodTypesManager() {
  const [page, setPage] = useState(0);
  const [showAddForm, setShowAddForm] = useState(false);
  const [editingType, setEditingType] = useState(null);
  const [showPriceHistory, setShowPriceHistory] = useState({});
  const [updatingPrice, setUpdatingPrice] = useState({});
  const [priceInputValues, setPriceInputValues] = useState({});
  const [priceValidationErrors, setPriceValidationErrors] = useState({});

  // New wood type form state
  const [newType, setNewType] = useState({
    neme: '',
    description: '',
    initial_price: ''
  });

  // API hooks
  const { data: woodTypes, loading: typesLoading, error: typesError, refetch: refetchTypes } =
    useApi(() => apiService.getWoodTypes(page, 10), [page]);

  const { data: allPrices, loading: pricesLoading, error: pricesError, refetch: refetchPrices } =
    useApi(() => apiService.getAllWoodTypePrices(), []); // Get all prices for history

  const { mutate, loading: mutating, error: mutationError, success } = useApiMutation();

  // Helper function to get current price for a wood type
  const getCurrentPrice = useCallback((woodTypeId) => {
    if (!allPrices?.data) return null;

    const typePrices = allPrices.data
      .filter(price => price.wood_type_id === woodTypeId)
      .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

    return typePrices[0] || null;
  }, [allPrices]);

  // Helper function to get price history for a wood type
  const getPriceHistory = useCallback((woodTypeId) => {
    if (!allPrices?.data) return [];

    return allPrices.data
      .filter(price => price.wood_type_id === woodTypeId)
      .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
  }, [allPrices]);

  // Helper function to format datetime with both date and time
  const formatDateTime = useCallback((dateString) => {
    if (!dateString) return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';

    const date = new Date(dateString);

    // Check if date is valid
    if (isNaN(date.getTime())) return '–ù–µ–≤–µ—Ä–Ω–∞—è –¥–∞—Ç–∞';

    // Format with both date and time in Russian locale
    const dateOptions = {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    };

    const timeOptions = {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    };

    const formattedDate = date.toLocaleDateString('ru-RU', dateOptions);
    const formattedTime = date.toLocaleTimeString('ru-RU', timeOptions);

    return `${formattedDate} –≤ ${formattedTime}`;
  }, []);

  // Form reset function
  const resetForm = useCallback(() => {
    setNewType({
      neme: '',
      description: '',
      initial_price: ''
    });
    setEditingType(null);
    setShowAddForm(false);
  }, []);

  // Enhanced wood type handlers with integrated pricing and transaction rollback
  const handleAddType = useCallback(async (e) => {
    e.preventDefault();
    console.log('üöÄ Form submitted - handleAddType called');
    console.log('üìù Form data:', newType);

    // Validation
    if (!newType.neme.trim()) {
      alert(SELLER_TEXTS.WOOD_TYPE_NAME_REQUIRED_ERROR);
      return;
    }

    if (newType.initial_price && (isNaN(parseFloat(newType.initial_price)) || parseFloat(newType.initial_price) <= 0)) {
      alert(SELLER_TEXTS.VALID_INITIAL_PRICE_ERROR);
      return;
    }

    console.log('‚úÖ Validation passed, proceeding with API calls');
    let createdWoodType = null;

    try {
      // Step 1: Create wood type (ID is auto-generated by backend)
      const woodTypeResponse = await mutate(() => apiService.createWoodType({
        neme: newType.neme.trim(),
        description: newType.description.trim() || null
      }));

      createdWoodType = woodTypeResponse.data;
      console.log('Wood type created successfully:', createdWoodType);

      // Step 2: Create initial price if provided
      if (newType.initial_price && parseFloat(newType.initial_price) > 0) {
        try {
          await mutate(() => apiService.createWoodTypePrice({
            wood_type_id: createdWoodType.id,
            price_per_m3: parseFloat(newType.initial_price)
          }));
          console.log('Initial price created successfully');
        } catch (priceError) {
          console.error('Failed to create initial price, rolling back wood type:', priceError);

          // Rollback: Delete the created wood type
          try {
            await mutate(() => apiService.deleteWoodType(createdWoodType.id));
            console.log('Wood type rollback completed');
          } catch (rollbackError) {
            console.error('Failed to rollback wood type creation:', rollbackError);
          }

          throw new Error('Failed to create initial price. Wood type creation has been rolled back.');
        }
      }

      // Success: Reset form and refresh data
      resetForm();
      refetchTypes();
      refetchPrices();

      // Show success message
      alert(`Wood type "${newType.neme}" created successfully!`);

    } catch (err) {
      console.error('Failed to add wood type:', err);

      // Extract meaningful error message
      let errorMessage = 'Failed to create wood type. Please try again.';
      if (err.response?.data?.detail) {
        errorMessage = err.response.data.detail;
      } else if (err.message) {
        errorMessage = err.message;
      }

      alert(errorMessage);
    }
  }, [newType, mutate, refetchTypes, refetchPrices, resetForm]);

  // Update wood type handler
  const handleUpdateType = useCallback(async (e) => {
    e.preventDefault();
    if (!editingType) return;

    try {
      await mutate(() => apiService.updateWoodType(editingType.id, {
        neme: editingType.neme,
        description: editingType.description
      }));
      setEditingType(null);
      refetchTypes();
    } catch (err) {
      console.error('Failed to update wood type:', err);
    }
  }, [editingType, mutate, refetchTypes]);

  // Delete wood type handler
  const handleDeleteType = useCallback(async (typeId) => {
    if (window.confirm(SELLER_TEXTS.CONFIRM_DELETE_WOOD_TYPE_FULL)) {
      try {
        await mutate(() => apiService.deleteWoodType(typeId));
        refetchTypes();
        refetchPrices(); // Refresh prices as they might be affected
      } catch (err) {
        console.error('Failed to delete wood type:', err);
      }
    }
  }, [mutate, refetchTypes, refetchPrices]);

  // Price update handler - creates new price record preserving history
  const handleUpdatePrice = useCallback(async (woodTypeId, newPrice) => {
    const price = parseFloat(newPrice);

    // Enhanced validation
    if (!newPrice || newPrice.trim() === '') {
      console.error('–¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π');
      return;
    }

    if (isNaN(price)) {
      console.error('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ü–µ–Ω—ã');
      return;
    }

    if (price <= 0) {
      console.error('–¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è');
      return;
    }

    if (price > 1000000) {
      console.error('–¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å 1,000,000 ‚ÇΩ/–º¬≥');
      return;
    }

    try {
      // Create new price record (preserves history, ID is auto-generated by backend)
      await mutate(() => apiService.createWoodTypePrice({
        wood_type_id: woodTypeId,
        price_per_m3: price
      }));

      // Success feedback
      console.log(`–¶–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞: ${price.toFixed(2)} ‚ÇΩ/–º¬≥`);

      // Clear all related state
      setUpdatingPrice({});
      setPriceInputValues(prev => ({...prev, [woodTypeId]: ''}));
      setPriceValidationErrors(prev => ({...prev, [woodTypeId]: null}));
      refetchPrices();
    } catch (err) {
      console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ü–µ–Ω—É:', err);
    }
  }, [mutate, refetchPrices]);

  // Real-time price validation
  const validatePrice = useCallback((value) => {
    if (!value || value.trim() === '') {
      return '–¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π';
    }

    const price = parseFloat(value);

    if (isNaN(price)) {
      return '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ';
    }

    if (price <= 0) {
      return '–¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è';
    }

    if (price > 1000000) {
      return '–¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å 1,000,000 ‚ÇΩ/–º¬≥';
    }

    return null;
  }, []);

  // Handle price input change with validation
  const handlePriceInputChange = useCallback((woodTypeId, value) => {
    setPriceInputValues(prev => ({
      ...prev,
      [woodTypeId]: value
    }));

    const error = validatePrice(value);
    setPriceValidationErrors(prev => ({
      ...prev,
      [woodTypeId]: error
    }));
  }, [validatePrice]);

  // Toggle price history visibility
  const togglePriceHistory = useCallback((woodTypeId) => {
    setShowPriceHistory(prev => ({
      ...prev,
      [woodTypeId]: !prev[woodTypeId]
    }));
  }, []);

  return (
    <div>
      <div className="page-header">
        <h1 className="page-title">{SELLER_TEXTS.WOOD_TYPE_MANAGEMENT}</h1>
        <p className="page-description">
          –£–ø—Ä–∞–≤–ª—è–π—Ç–µ —Ç–∏–ø–∞–º–∏ –¥—Ä–µ–≤–µ—Å–∏–Ω—ã –∏ –∏—Ö —Ü–µ–Ω–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º –≤ –µ–¥–∏–Ω–æ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ. –û–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω —Å–æ—Ö—Ä–∞–Ω—è—é—Ç –ø–æ–ª–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è –±–∏–∑–Ω–µ—Å-–∞–Ω–∞–ª–∏—Ç–∏–∫–∏.
        </p>
      </div>

      {/* Error and Success Messages */}
      {mutationError && (
        <div className="error mb-4">
          <strong>{SELLER_TEXTS.OPERATION_FAILED}:</strong> {mutationError}
        </div>
      )}

      {success && (
        <div className="success mb-4">
          <strong>{SELLER_TEXTS.SUCCESS}:</strong> {SELLER_TEXTS.OPERATION_SUCCESSFUL}!
        </div>
      )}

      {/* Main Management Interface */}
      <div className="card mb-6">
        <div className="card-header">
          <h2 className="card-title">{SELLER_TEXTS.WOOD_TYPES} –∏ {SELLER_TEXTS.PRICING}</h2>
          <p style={{ color: 'var(--color-text-light)', fontSize: 'var(--font-size-sm)', marginTop: 'var(--space-2)' }}>
            –ï–¥–∏–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–∏–ø–∞–º–∏ –¥—Ä–µ–≤–µ—Å–∏–Ω—ã –∏ –∏—Ö —Ü–µ–Ω–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º
          </p>
        </div>

        <div className="flex justify-between items-center mb-4">
          <div>
            <p>{SELLER_TEXTS.TOTAL} {SELLER_TEXTS.WOOD_TYPES}: {woodTypes?.data?.length || 0}</p>
            {pricesLoading && <p style={{ color: 'var(--color-text-light)', fontSize: 'var(--font-size-sm)' }}>{SELLER_TEXTS.LOADING} –¥–∞–Ω–Ω—ã—Ö –æ —Ü–µ–Ω–∞—Ö...</p>}
          </div>
          <div className="flex gap-4">
            <button
              onClick={() => setShowAddForm(!showAddForm)}
              className={`btn ${showAddForm ? 'btn-secondary' : 'btn-primary'}`}
            >
              {showAddForm ? SELLER_TEXTS.CANCEL : `${SELLER_TEXTS.ADD} ${SELLER_TEXTS.WOOD_TYPE}`}
            </button>
            <button
              onClick={() => {
                refetchTypes();
                refetchPrices();
              }}
              className="btn btn-secondary"
              disabled={typesLoading || pricesLoading}
            >
              {typesLoading || pricesLoading ? `${SELLER_TEXTS.LOADING}...` : SELLER_TEXTS.REFRESH}
            </button>
          </div>
        </div>

        {/* Error States */}
        {typesError && (
          <div className="error mb-4">
            Failed to load wood types: {typesError}
          </div>
        )}

        {pricesError && (
          <div className="error mb-4">
            {SELLER_TEXTS.FAILED_TO_LOAD_PRICES}: {pricesError}
          </div>
        )}

        {/* Add Wood Type Form */}
        {showAddForm && (
          <div className="card mb-4">
            <div className="card-header">
              <h3 className="card-title">{SELLER_TEXTS.ADD_NEW_WOOD_TYPE}</h3>
              <p style={{ color: 'var(--color-text-light)', fontSize: 'var(--font-size-sm)', marginTop: 'var(--space-2)' }}>
                {SELLER_TEXTS.CREATE_NEW_WOOD_TYPE_DESC}
              </p>
            </div>
            <form onSubmit={handleAddType}>
              <div className="form-group">
                <label className="form-label">{SELLER_TEXTS.WOOD_TYPE_NAME_REQUIRED}</label>
                <input
                  type="text"
                  className="form-input"
                  value={newType.neme}
                  onChange={(e) => setNewType({...newType, neme: e.target.value})}
                  placeholder={SELLER_TEXTS.WOOD_TYPE_NAME_EXAMPLES}
                  required
                  maxLength={100}
                />
              </div>

              <div className="form-group">
                <label className="form-label">{SELLER_TEXTS.DESCRIPTION}</label>
                <textarea
                  className="form-input"
                  value={newType.description}
                  onChange={(e) => setNewType({...newType, description: e.target.value})}
                  placeholder={SELLER_TEXTS.WOOD_TYPE_DESCRIPTION_LONG}
                  rows="3"
                  maxLength={500}
                />
                <small style={{ color: 'var(--color-text-light)', fontSize: 'var(--font-size-xs)' }}>
                  {newType.description.length}/500 {SELLER_TEXTS.CHARACTERS}
                </small>
              </div>

              <div className="form-group">
                <label className="form-label">{SELLER_TEXTS.INITIAL_PRICE_M3}</label>
                <input
                  type="number"
                  step="0.01"
                  min="0"
                  className="form-input"
                  value={newType.initial_price}
                  onChange={(e) => setNewType({...newType, initial_price: e.target.value})}
                  placeholder={SELLER_TEXTS.INITIAL_PRICE_EXAMPLE}
                />
                <small style={{ color: 'var(--color-text-light)', fontSize: 'var(--font-size-xs)' }}>
                  {SELLER_TEXTS.INITIAL_PRICE_HELP}
                </small>
              </div>

              <div className="flex gap-4" style={{ marginTop: 'var(--space-6)' }}>
                <button type="submit" className="btn btn-primary" disabled={mutating}>
                  {mutating ? SELLER_TEXTS.CREATING : SELLER_TEXTS.CREATE_WOOD_TYPE}
                </button>
                <button type="button" className="btn btn-secondary" onClick={resetForm} disabled={mutating}>
                  {SELLER_TEXTS.CANCEL}
                </button>
              </div>
            </form>
          </div>
        )}

        {/* Loading State */}
        {typesLoading && <div className="loading">{SELLER_TEXTS.LOADING_WOOD_TYPES}</div>}

        {/* Wood Types Table with Integrated Pricing */}
        {woodTypes && woodTypes.data && woodTypes.data.length > 0 ? (
          <table className="table">
            <thead>
              <tr>
                <th>{SELLER_TEXTS.WOOD_TYPE}</th>
                <th>{SELLER_TEXTS.DESCRIPTION}</th>
                <th>{SELLER_TEXTS.CURRENT_PRICE}</th>
                <th>{SELLER_TEXTS.PRICE_HISTORY}</th>
                <th>{SELLER_TEXTS.ACTIONS}</th>
              </tr>
            </thead>
            <tbody>
              {woodTypes.data.map((type) => {
                const currentPrice = getCurrentPrice(type.id);
                const priceHistory = getPriceHistory(type.id);
                const isEditing = editingType?.id === type.id;
                const isUpdatingPrice = updatingPrice[type.id];

                return (
                  <tr key={type.id}>
                    {/* Wood Type Name */}
                    <td>
                      {isEditing ? (
                        <input
                          type="text"
                          value={editingType.neme}
                          onChange={(e) => setEditingType({...editingType, neme: e.target.value})}
                          className="form-input"
                          style={{ margin: 0 }}
                          placeholder={SELLER_TEXTS.WOOD_TYPE_NAME_PLACEHOLDER}
                        />
                      ) : (
                        <div>
                          <strong>{type.neme || SELLER_TEXTS.UNNAMED_TYPE}</strong>
                          <div style={{ fontSize: 'var(--font-size-xs)', color: 'var(--color-text-light)', marginTop: '0.25rem' }}>
                            ID: {type.id.substring(0, 8)}...
                          </div>
                        </div>
                      )}
                    </td>

                    {/* Description */}
                    <td>
                      {isEditing ? (
                        <textarea
                          value={editingType.description || ''}
                          onChange={(e) => setEditingType({...editingType, description: e.target.value})}
                          className="form-input"
                          style={{ margin: 0 }}
                          rows="2"
                          placeholder={SELLER_TEXTS.DESCRIPTION_PLACEHOLDER}
                        />
                      ) : (
                        <div>
                          {type.description ? (
                            <span>{type.description.length > 100 ? `${type.description.substring(0, 100)}...` : type.description}</span>
                          ) : (
                            <em style={{ color: 'var(--color-text-light)' }}>{SELLER_TEXTS.NO_DESCRIPTION}</em>
                          )}
                        </div>
                      )}
                    </td>

                    {/* Current Price with Inline Update */}
                    <td>
                      {isUpdatingPrice ? (
                        <div style={{ position: 'relative' }}>
                          <input
                            type="number"
                            step="0.01"
                            min="0"
                            value={priceInputValues[type.id] || ''}
                            onChange={(e) => handlePriceInputChange(type.id, e.target.value)}
                            style={{
                              width: '120px',
                              padding: '6px 8px',
                              border: `1px solid ${priceValidationErrors[type.id] ? 'var(--color-error)' : 'var(--color-primary)'}`,
                              borderRadius: '4px',
                              fontSize: 'var(--font-size-base)',
                              outline: 'none',
                              backgroundColor: priceValidationErrors[type.id] ? '#fef2f2' : 'white',
                              transition: 'border-color 0.2s ease'
                            }}
                            placeholder="0.00"
                            onKeyDown={(e) => {
                              if (e.key === 'Enter' && !priceValidationErrors[type.id]) {
                                handleUpdatePrice(type.id, e.target.value);
                              }
                              if (e.key === 'Escape') {
                                setUpdatingPrice(prev => ({...prev, [type.id]: false}));
                                setPriceInputValues(prev => ({...prev, [type.id]: ''}));
                                setPriceValidationErrors(prev => ({...prev, [type.id]: null}));
                              }
                            }}
                            onBlur={(e) => {
                              // –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Ñ–æ–∫—É—Å–∞, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
                              const newValue = e.target.value;
                              const currentValue = currentPrice?.price_per_m3?.toString() || '';
                              if (newValue && newValue !== currentValue && !priceValidationErrors[type.id]) {
                                handleUpdatePrice(type.id, newValue);
                              } else {
                                // –û—Ç–º–µ–Ω–∞ –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
                                setUpdatingPrice(prev => ({...prev, [type.id]: false}));
                                setPriceInputValues(prev => ({...prev, [type.id]: ''}));
                                setPriceValidationErrors(prev => ({...prev, [type.id]: null}));
                              }
                            }}
                            autoFocus
                          />
                          <span style={{
                            position: 'absolute',
                            right: '8px',
                            top: '50%',
                            transform: 'translateY(-50%)',
                            color: 'var(--color-text-light)',
                            fontSize: 'var(--font-size-sm)',
                            pointerEvents: 'none'
                          }}>
                            ‚ÇΩ/–º¬≥
                          </span>

                          {/* –ö–æ–º–ø–∞–∫—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ */}
                          {priceValidationErrors[type.id] && (
                            <div style={{
                              position: 'absolute',
                              top: '100%',
                              left: 0,
                              right: 0,
                              marginTop: '2px',
                              padding: '2px 6px',
                              backgroundColor: 'var(--color-error)',
                              color: 'white',
                              borderRadius: '3px',
                              fontSize: 'var(--font-size-xs)',
                              zIndex: 10,
                              whiteSpace: 'nowrap'
                            }}>
                              {priceValidationErrors[type.id]}
                            </div>
                          )}
                        </div>
                      ) : (
                        <div
                          onClick={() => {
                            setUpdatingPrice(prev => ({...prev, [type.id]: true}));
                            // Pre-fill with current price if available
                            if (currentPrice) {
                              setPriceInputValues(prev => ({...prev, [type.id]: currentPrice.price_per_m3.toString()}));
                            } else {
                              setPriceInputValues(prev => ({...prev, [type.id]: ''}));
                              setPriceValidationErrors(prev => ({...prev, [type.id]: null}));
                            }
                          }}
                          style={{
                            padding: '8px 12px',
                            border: '1px solid transparent',
                            borderRadius: '4px',
                            cursor: 'pointer',
                            transition: 'all 0.2s ease',
                            minHeight: '36px',
                            display: 'flex',
                            alignItems: 'center',
                            backgroundColor: currentPrice ? '#f8fafc' : '#f9fafb'
                          }}
                          onMouseEnter={(e) => {
                            e.target.style.borderColor = '#e5e7eb';
                            e.target.style.backgroundColor = currentPrice ? '#f1f5f9' : '#f3f4f6';
                          }}
                          onMouseLeave={(e) => {
                            e.target.style.borderColor = 'transparent';
                            e.target.style.backgroundColor = currentPrice ? '#f8fafc' : '#f9fafb';
                          }}
                        >
                          {currentPrice ? (
                            <div style={{ width: '100%' }}>
                              <div style={{
                                fontSize: 'var(--font-size-base)',
                                fontWeight: '600',
                                color: 'var(--color-text)',
                                marginBottom: '2px'
                              }}>
                                {currentPrice.price_per_m3.toFixed(2)} ‚ÇΩ/–º¬≥
                              </div>
                              <div style={{
                                fontSize: 'var(--font-size-xs)',
                                color: 'var(--color-text-light)'
                              }}>
                                {formatDateTime(currentPrice.created_at)}
                              </div>
                            </div>
                          ) : (
                            <div style={{
                              fontSize: 'var(--font-size-base)',
                              color: 'var(--color-text-light)',
                              fontStyle: 'italic'
                            }}>
                              {SELLER_TEXTS.CLICK_TO_SET_PRICE}
                            </div>
                          )}
                        </div>
                      )}
                    </td>

                    {/* Price History */}
                    <td>
                      {priceHistory.length > 0 ? (
                        <div>
                          <div style={{ fontSize: 'var(--font-size-sm)', marginBottom: '0.5rem' }}>
                            <strong>{priceHistory.length}</strong> {getPriceRecordsText(priceHistory.length)}
                          </div>
                          <button
                            onClick={() => togglePriceHistory(type.id)}
                            className="btn btn-secondary"
                            style={{ fontSize: '0.7em', padding: '0.2rem 0.4rem' }}
                          >
                            {showPriceHistory[type.id] ? SELLER_TEXTS.HIDE_HISTORY : SELLER_TEXTS.SHOW_HISTORY}
                          </button>

                          {showPriceHistory[type.id] && (
                            <div style={{ marginTop: '0.5rem', padding: '0.5rem', backgroundColor: 'var(--color-bg-light)', borderRadius: 'var(--border-radius)' }}>
                              <div style={{ fontSize: 'var(--font-size-xs)', fontWeight: '600', marginBottom: '0.5rem' }}>
                                {SELLER_TEXTS.PRICE_HISTORY}:
                              </div>
                              {priceHistory.map((price, index) => (
                                <div key={price.id} style={{
                                  fontSize: 'var(--font-size-xs)',
                                  marginBottom: '0.25rem',
                                  color: index === 0 ? 'var(--color-success)' : 'var(--color-text-light)'
                                }}>
                                  <strong>{price.price_per_m3.toFixed(2)} ‚ÇΩ/–º¬≥</strong>
                                  <div style={{ fontSize: 'var(--font-size-xs)', color: 'var(--color-text-light)' }}>
                                    {formatDateTime(price.created_at)}
                                    {index === 0 && <span style={{ color: 'var(--color-success)', marginLeft: '0.5rem' }}>({SELLER_TEXTS.CURRENT})</span>}
                                  </div>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      ) : (
                        <em style={{ color: 'var(--color-text-light)' }}>{SELLER_TEXTS.NO_PRICE_HISTORY}</em>
                      )}
                    </td>

                    {/* Actions */}
                    <td>
                      <div className="flex gap-2">
                        {isEditing ? (
                          <>
                            <button
                              onClick={handleUpdateType}
                              className="btn btn-primary"
                              disabled={mutating}
                              style={{ fontSize: '0.8em', padding: '0.25rem 0.5rem' }}
                            >
                              {SELLER_TEXTS.SAVE}
                            </button>
                            <button
                              onClick={() => setEditingType(null)}
                              className="btn btn-secondary"
                              style={{ fontSize: '0.8em', padding: '0.25rem 0.5rem' }}
                            >
                              {SELLER_TEXTS.CANCEL}
                            </button>
                          </>
                        ) : (
                          <>
                            <button
                              onClick={() => setEditingType(type)}
                              className="btn btn-secondary"
                              style={{ fontSize: '0.8em', padding: '0.25rem 0.5rem' }}
                            >
                              {SELLER_TEXTS.EDIT}
                            </button>
                            <button
                              onClick={() => handleDeleteType(type.id)}
                              className="btn btn-secondary"
                              disabled={mutating}
                              style={{
                                fontSize: '0.8em',
                                padding: '0.25rem 0.5rem',
                                backgroundColor: '#fee2e2',
                                color: 'var(--color-error)'
                              }}
                            >
                              {SELLER_TEXTS.DELETE}
                            </button>
                          </>
                        )}
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        ) : (
          <div className="text-center">
            <p>{SELLER_TEXTS.NO_WOOD_TYPES_FOUND}</p>
            <button
              onClick={() => setShowAddForm(true)}
              className="btn btn-primary mt-4"
            >
              {SELLER_TEXTS.ADD_FIRST_WOOD_TYPE}
            </button>
          </div>
        )}

        {/* Pagination */}
        {woodTypes && woodTypes.data && woodTypes.data.length > 0 && (
          <div className="flex justify-between items-center mt-6">
            <button
              onClick={() => setPage(Math.max(0, page - 1))}
              disabled={page === 0 || typesLoading}
              className="btn btn-secondary"
            >
              {SELLER_TEXTS.PREVIOUS}
            </button>
            <span>{SELLER_TEXTS.PAGE} {page + 1}</span>
            <button
              onClick={() => setPage(page + 1)}
              disabled={!woodTypes?.data || woodTypes.data.length < 10 || typesLoading}
              className="btn btn-secondary"
            >
              {SELLER_TEXTS.NEXT}
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

export default WoodTypesManager;
